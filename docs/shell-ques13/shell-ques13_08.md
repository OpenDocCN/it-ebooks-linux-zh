# 8.$(())与$()还有${}的差别在哪

## shell 十三问之 8: $(())与$()还有${}差在哪？

* * *

我们上一章介绍了()与{}的不同， 这次让我们扩展一下，看看更多的变化： $()与${}又是啥玩意儿呢？

在 bash shell 中, `$()`与``(反引号)都是用来做 `命令替换`(command substitution)的。

所谓的`命令替换`与我们第五章学过的变量替换差不多， 都是用来`重组命令行`： 完成 `` 或者`$()`里面的 命令，将其结果替换出来， 再重组命令行。

例如：

```
$ echo the last sunday is $(date -d "last sunday" +%Y-%m-%d) 
```

如此便可方便得到上一个星期天的日期了...^_^

在操作上， 用$()或``都无所谓, 只是我个人比较喜欢用$(),理由是：

1.  ``(反引号)很容易与''(单引号)搞混乱，尤其对初学者来说。 有时在一些奇怪的字形显示中，两种符号是一模一样的(只取两点)。 当然了有经验的朋友还是一眼就能分辨两者。只是，若能更好的避免混乱， 又何乐而不为呢？ ^_^

2.  在多次的复合替换中， ``需要额外的转义(escape, )处理，而$()则比较直观。 例如，一个错误的使用的例子：

    ```
    command1 `command2 `command3` ` 
    ```

    原来的本意是要在 command2 `command3` , 先将 command3 替换出来给 command2 处理， 然后再将 command2 的处理结果，给 command1 来处理。 然而真正的结果在命令行中却是分成了`command2`与 ``。

正确的输入应该如下：

```
 command1 `command2 \`command3\` ` 
```

要不然换成$()就没有问题了：

```
 command1 $(commmand2 $(command3)) 
```

只要你喜欢，做多少层的替换都没有问题~~~^_^

不过，$()并不是没有弊端的... 首先，``基本上可用在所有的 unix shell 中使用， 若写成 shell script，其移植性比较高。 而$()并不是每一种 shell 都能使用，我只能说， 若你用 bash2 的话，肯定没问题... ^_^

接下来，再让我们看看${}吧...它其实就是用来做 变量替换用的啦。 一般情况下，$var 与${var}并没有啥不一样。 但是用${}会比较精准的界定变量名称的范围， 比方说:

```
$ A=B
$ echo $AB 
```

原本是打算先将$A 的结果替换出来， 然后在其后补一个字母 B； 但命令行上， 真正的结果却是替换变量名称为 AB 的值出来... 若使用${}就没有问题了：

```
$ A=B
$ echo ${A}B
$ BB 
```

不过，假如你只看到`${}`只能用来界定变量名称的话， 那你就实在太小看 bash 了。

为了完整起见，我这里再用一些例子加以说明`${}`的一些 特异功能： 假设我们定义了一个变量 file 为：

```
file=/dir1/dir2/dir3/my.file.txt 
```

我们可以用`${}`分别替换获得不同的值：

#### 1\. shell 字符串的非贪婪(最小匹配)左删除

* * *

```
${file#*/}  #其值为：dir1/dir2/dir3/my.file.txt 
```

拿掉第一个`/`及其左边的字符串，其结果为： `dir1/dir2/dir3/my.file.txt` 。

```
${file#*.}  #其值为：file.txt 
```

拿掉第一个`.`及其左边的字符串，其结果为： `file.txt` 。

#### 2\. shell 字符串的贪婪(最大匹配)左删除：

* * *

```
${file##*/} #其值为：my.file.txt 
```

拿掉最后一个`/`及其左边的字符串，其结果为： `my.file.txt`

```
${file##*.} #其值为：txt 
```

拿掉最后一个`.`及其左边的字符串，其结果为： `txt`

#### 3\. shell 字符串的非贪婪(最小匹配)右删除：

* * *

```
${file%/*}  #其值为：/dir1/dir2/dir3 
```

拿掉最后一个`/`及其右边的字符串，其结果为： `/dir1/dir2/dir3`。

```
${file%.*}  #其值为：/dir1/dir2/dir3/my.file 
```

拿掉最后一个`.`及其右边的字符串，其结果为： `/dir1/dir2/dir3/my.file`。

#### 4\. shell 字符串的贪婪(最大匹配)右删除：

* * *

```
${file%%/*}  #其值为：其值为空。 
```

拿掉第一个`/`及其右边的字符串，其结果为： 空串。

```
${file%%.*}  #其值为：/dir1/dir2/dir3/my。 
```

拿掉第一个`.`及其右边的字符串，其结果为： /dir1/dir2/dir3/my。

> **Tips:**
> 
> 记忆方法：
> 
> `#`是去掉左边(在键盘上`#`在`$`的左边);
> 
> `%`是去掉右边(在键盘上`%`在`$`的右边);
> 
> 单个符号是最小匹配;
> 
> 两个符号是最大匹配;

#### 5\. shell 字符串取子串：

* * *

```
 ${file:0:5} #提取最左边的 5 个字符：/dir1
 ${file:5:5} #提取第 5 个字符及其右边的 5 个字符:/dir2 
```

shell 字符串取子串的格式：`${s:pos:length}`, 取字符串 s 的子串：从 pos 位置开始的字符(包括该字符)的长度为 length 的的子串; 其中 pos 为子串的首字符，在 s 中位置； length 为子串的长度;

> **Note:** 字符串中字符的起始编号为 0.

#### 6\. shell 字符串变量值的替换：

* * *

```
${file/dir/path}  #将第一个 dir 替换为 path：/path1/dir2/dir3/my.file.txt
${file//dir/path} #将全部的 dir 替换为 path：/path1/path2/path3/my.file.txt 
```

shell 字符串变量值的替换格式：

*   首次替换： `${s/src_pattern/dst_pattern}` 将字符串 s 中的第一个 src_pattern 替换为 dst_pattern。

*   全部替换： `${s//src_pattern/dst_pattern}` 将字符串 s 中的所有出现的 src_pattern 替换为 dst_pattern.

#### 7\. ${}还可针对变量的不同状态(没设定、空值、非空值)进行赋值：

* * *

*   `${file-my.file.txt}` #如果 file 没有设定，则使用 使用 my.file.txt 作为返回值, 否则返回${file};(空值及非空值时，不作处理。);

*   `${file:-my.file.txt}` #如果 file 没有设定或者${file}为空值, 均使用 my.file.txt 作为其返回值，否则，返回${file}.(${file} 为非空值时，不作处理);

*   `${file+my.file.txt}` #如果 file 已设定(为空值或非空值), 则使用 my.file.txt 作为其返回值，否则不作处理。(未设定时，不作处理);

*   `${file:+my.file.txt}` #如果${file}为非空值, 则使用 my.file.txt 作为其返回值，否则，(未设定或者为空值时)不作处理。

*   `${file=my.file.txt}` #如果 file 为设定，则将 file 赋值为 my.file.txt，同时将${file}作为其返回值；否则，file 已设定(为空值或非空值)，则返回${file}。

*   `${file:=my.file.txt}` #如果 file 未设定或者${file}为空值, 则 my.file.txt 作为其返回值， 同时，将${file}赋值为 my.file.txt，否则，(非空值时)不作处理。

*   `${file?my.file.txt}` #如果 file 没有设定，则将 my.file.txt 输出至 STDERR, 否侧， 已设定(空值与非空值时)，不作处理。

*   `${file:?my.file.txt}` #若果 file 未设定或者为空值，则将 my.file.txt 输出至 STDERR，否则， 非空值时，不作任何处理。

> **Tips:**
> 
> 以上的理解在于，你一定要分清楚，`unset`与`null`以及 non-null 这三种状态的赋值； 一般而言，与 null 有关，若不带`:`, null 不受影响； 若带 `:`, 则连 null 值也受影响。

#### 8\. 计算 shell 字符串变量的长度：`$`

* * *

```
 ${#file}  #其值为 27, 因为/dir1/dir2/dir3/my.file.txt 刚好为 27 个字符。 
```

#### 9\. bash 数组(array)的处理方法

* * *

接下来，为大家介绍一下 bash 的数组(array)的处理方法。 一般而言, `A="a b c def"` 这样的变量只是将`$A`替换为一个字符串， 但是改为 `A=(a b c def)`, 则是将`$A`定义为数组....

##### 1). 数组替换方法可参考如下方法：

```
${A[@]} #方法一
${A[*]} #方法二 
```

以上两种方法均可以得到：a b c def, 即数组的全部元素。

##### 2). 访问数组的成员:

```
${A[0]} 
```

其中，`${A[0]}`可得到 a, 即数组 A 的第一个元素， 而 `${A[1]}`则为数组 A 的第二元素，依次类推。

##### 3). 数组的 length：

```
${#A[@]} #方法一
${#A[*]} #方法二 
```

以上两种方法均可以得到数组的长度: 4, 即数组的所有元素的个数。

回忆一下，针对字符串的长度计算，使用`${#str_var}`; 我们同样可以将该方法应用于数组的成员:

```
${#A[0]} 
```

其中，`${#A[0]}`可以得到：1，即数组 A 的第一个元素(a)的长度; 同理，`${#A[3]}`可以得到: 3, 即数组 A 的第 4 个元素(def)的长度。

##### 4). 数组元素的重新赋值：

```
A[3]=xyz 
```

将数组 A 的第四个元素重新定义为 xyz。

> **Tips:**
> 
> 诸如此类的...
> 
> 能够善用 bash 的$()与${}可以大大提高及 简化 shell 在变量上的处理能力哦~~~^_^

#### 10\. $(())作用:

* * *

好了，最后为大家介绍`$(())`的用途吧： **`$(())`是用来作整数运算的**。

在 bash 中， `$(())`的整数运算符号大致有这些：

*   +- * / #分别为"加、减、乘、除"。
*   % #余数运算,(模数运算)
*   & | ^ ! #分别为"AND、OR、XOR、NOT"运算。

例如：

```
$ a=5; b=7; c=2;
$ echo $(( a + b * c ))
19
$ echo $(( (a + b)/c ))
6
$ echo $(( (a * b) % c ))
1 
```

在`$(())`中的变量名称, 可以在其前面加 `$`符号来替换， 也可以不用，如： `$(( $a + $b * $c ))` 也可以得到 19 的结果。

此外，`$(())`还可作不同进制(如二进制、八进制、十六进制)的运算， 只是输出结果均为十进制的。

```
echo $(( 16#2a )) #输出结果为：42，(16 进制的 2a) 
```

以一个实用的例子来看看吧 : 假如当前的 umask 是 022,那么新建文件的权限即为：

```
$ umask 022
$ echo "obase=8; $(( 8#666 & (8#777 ^ 8#$(umask)) ))" | bc
644 
```

事实上，单纯用`(())`也可以重定义变量值，或作 testing：

```
a=5; ((a++)) #可将$a 重定义为 6
a=5; ((a--)) #可将$a 重定义为 4
a=5; b=7; ((a< b)) #会得到 0 (true)返回值。 
```

常见的用于`(())`的测试符号有如下这些：

| 符号 | 符号名称 |
| --- | --- |
| < | 小于号 |
| > | 大于号 |
| <= | 小于或等于 |
| >= | 大于或等于 |
| == | 等于 |
| != | 不等于 |

> **Note:**
> 
> 使用`(())`作整数测试时， 请不要跟`[]`的整数测试搞混乱了。
> 
> 更多的测试，我们将于第十章为大家介绍。

怎样？ 好玩吧... ^_^

okay,这次暂时说这么多...

上面的介绍，并没有详列每一种可用的状态， 更多的，就请读者参考手册文件(man)吧...